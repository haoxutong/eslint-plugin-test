/**
 * @author Toru Nagashima
 * @copyright 2015 Toru Nagashima. All rights reserved.
 */

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

exports["default"] = rule;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var scopeNodeType = /^(?:(?:Block|Switch|For(?:In|Of)?)Statement|CatchClause|Program)$/;
var containerNodeType = /^(?:For(?:In|Of)?Statement|(?:Arrow)?Function(?:Declaration|Expression))$/;

/**
 * Collects unresolved references from the global scope, then creates a map to references from its name.
 * @param {RuleContext} context - The current context.
 * @returns {object} A map object. Its key is the variable names. Its value is the references of each variable.
 */
function collectUnresolvedReferences(context) {
    var unresolved = Object.create(null);
    var references = context.getScope().through;

    for (var i = 0; i < references.length; ++i) {
        var reference = references[i];
        var _name = reference.identifier.name;

        if (_name in unresolved === false) {
            unresolved[_name] = [];
        }
        unresolved[_name].push(reference);
    }

    return unresolved;
}

/**
 * Checks whether or not a given definition should be skipped.
 * @param {escope.Variable.DefEntry} def - A definition to check.
 * @param {escope.Variable.DefEntry[]} defs - A definition list which includes `def`.
 * @param {escope.Variable} variable - A variable which is defined by the definition.
 * @returns {boolean} Whether or not the definition should be skipped.
 */
function shouldSkip(def, defs, variable) {
    // To check re-declarations.
    if (defs.length >= 2 && def.type !== "TDZ") {
        return false;
    }

    switch (def.type) {
        case "ClassName":
        case "FunctionName":
            return variable.scope.block === def.node;

        case "Parameter":
        case "TDZ":
            return true;

        case "Variable":
            return def.parent.kind !== "var";

        default:
            return false;
    }
}

/**
 * Pseudo scope information for `var`.
 */

var PseudoScope = (function () {
    /**
     * Finds and creates information of a containing scope of a given declaration.
     * @param {escope.Variable.DefineEntry} def - A declaration.
     */

    function PseudoScope(def) {
        _classCallCheck(this, PseudoScope);

        var node = null;

        if (def.type === "Parameter") {
            node = def.node;
        } else {
            node = (def.parent || def.node).parent;

            while (!scopeNodeType.test(node.type)) {
                node = node.parent;
            }
            if (node.parent != null && containerNodeType.test(node.parent.type)) {
                node = node.parent;
            }
        }

        /**
         * The `Identifier` node of the declaration.
         * @type {ASTNode}
         */
        this.identifier = def.name;

        /**
         * The start position of the scope.
         * @type {number}
         */
        this.start = node.range[0];

        /**
         * The end position of the scope.
         * @type {number}
         */
        this.end = node.range[1];

        /**
         * The `Identifier` nodes of re-declarations.
         * @type {ASTNode[]}
         */
        this.redeclarations = [];

        /**
         * The `PseudoScope` instances which are nested.
         * @type {PseudoScope[]}
         */
        this.children = [];

        /**
         * The flag of shadowing.
         * @type {boolean}
         */
        this.shadowing = false;

        /**
         * The flag of used.
         * @type {boolean}
         */
        this.used = false;
    }

    //------------------------------------------------------------------------------
    // Rule Definition
    //------------------------------------------------------------------------------

    /**
     * Creates pseudo scopes of a given variable.
     * @param {escope.Variable} variable - A variable to create.
     * @returns {PseudoScope[]} the created scopes.
     */

    _createClass(PseudoScope, [{
        key: "markAsShadowing",

        /**
         * Turns a shadowing flag on.
         * @returns {void}
         */
        value: function markAsShadowing() {
            this.shadowing = true;
        }

        /**
         * Turns an used flag on.
         * @returns {void}
         */
    }, {
        key: "markAsUsed",
        value: function markAsUsed() {
            this.used = true;
        }
    }], [{
        key: "createScopesFrom",
        value: function createScopesFrom(variable) {
            var defs = variable.defs;
            var scopes = [];
            for (var j = 0; j < defs.length; ++j) {
                var def = defs[j];
                if (!shouldSkip(def, defs, variable)) {
                    PseudoScope.push(scopes, new PseudoScope(def));
                }
            }
            return scopes;
        }

        /**
         * Adds a given scope into a given scope list.
         * This considers re-declarations and shadowing.
         * @param {PseudoScope[]} scopes - Scopes to be added.
         * @param {PseudoScope} newScope - A scope to add.
         * @returns {void}
         */
    }, {
        key: "push",
        value: function push(scopes, newScope) {
            for (var i = 0; i < scopes.length; ++i) {
                var scope = scopes[i];

                if (scope.start === newScope.start && scope.end === newScope.end) {
                    scope.redeclarations.push(newScope.identifier);
                    return;
                }
                if (scope.start <= newScope.start && newScope.end <= scope.end) {
                    newScope.markAsShadowing();
                    PseudoScope.push(scope.children, newScope);
                    return;
                }
            }

            scopes.push(newScope);
        }

        /**
         * Finds a containing scope of a given reference.
         * @param {PseudoScope[]} scopes - Scopes to be domain.
         * @param {escope.Reference} reference - A reference to find.
         * @returns {PseudoScope|null} A containing scope of the reference.
         */
    }, {
        key: "findScope",
        value: function findScope(scopes, reference) {
            var range = reference.identifier.range;

            for (var i = 0; i < scopes.length; ++i) {
                var scope = scopes[i];

                if (scope.start < range[0] && range[1] < scope.end) {
                    return PseudoScope.findScope(scope.children, reference) || scope;
                }
            }

            return null;
        }
    }]);

    return PseudoScope;
})();

function rule(context) {
    var unresolvedReferences = Object.create(null);

    /**
     * Finds and reports references which are outside of valid scopes.
     * @param {ASTNode} node - A node to get variables.
     * @returns {void}
     */
    function checkForVariables(node) {
        var isGlobal = context.getScope().type === "global";
        var variables = context.getDeclaredVariables(node);

        var _loop = function (i) {
            var variable = variables[i];
            var defs = variable.defs;
            var lastDef = defs[defs.length - 1];

            // Skip except the last declaration.
            // Because `node.parent` is possibly not defined.
            if ((lastDef.parent || lastDef.node) !== node) {
                return "continue";
            }

            // Collect the containing scopes.
            var scopes = PseudoScope.createScopesFrom(variable);
            if (scopes.length === 0) {
                return "continue";
            }

            // Some global variables are possibly unresolved.
            // In this case, use unresolved references.
            var references = variable.references;
            if (isGlobal && variable.name in unresolvedReferences) {
                references = unresolvedReferences[variable.name];
            }

            // Check whether or not any reading reference exists.
            // And while it does, warn references which does not belong to any scope.
            var hasReadRef = false;
            for (var j = 0; j < references.length; ++j) {
                var reference = references[j];
                var scope = PseudoScope.findScope(scopes, reference);

                if (reference.isRead()) {
                    hasReadRef = true;
                    if (scope != null) {
                        scope.markAsUsed();
                    }
                }

                if (scope == null) {
                    context.report(reference.identifier, "\"{{name}}\" is not defined.", { name: reference.identifier.name });
                }
            }

            // Warn re-declarations, shadowing, and unused.
            scopes.forEach(function walk(scope) {
                // eslint-disable-line no-loop-func
                for (var j = 0; j < scope.redeclarations.length; ++j) {
                    var identifier = scope.redeclarations[j];
                    context.report(identifier, "\"{{name}}\" is already defined.", { name: identifier.name });
                }

                if (scope.shadowing) {
                    context.report(scope.identifier, "\"{{name}}\" is already defined in the upper scope.", { name: scope.identifier.name });
                }

                if (hasReadRef && !scope.used) {
                    context.report(scope.identifier, "\"{{name}}\" is defined but never used.", { name: scope.identifier.name });
                }

                scope.children.forEach(walk);
            });
        };

        for (var i = 0; i < variables.length; ++i) {
            var _ret = _loop(i);

            if (_ret === "continue") continue;
        }
    }

    return {
        Program: function Program() {
            unresolvedReferences = collectUnresolvedReferences(context);
        },

        VariableDeclaration: checkForVariables,
        FunctionDeclaration: checkForVariables,
        ClassDeclaration: checkForVariables,
        ImportDeclaration: checkForVariables
    };
}

rule.schema = [];
module.exports = exports["default"];